<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>state | Vue 源码解析</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Vue源码解析 从new Vue源码还原">
    
    <link rel="preload" href="/the-blog/assets/css/0.styles.5847df6a.css" as="style"><link rel="preload" href="/the-blog/assets/js/app.be1bf052.js" as="script"><link rel="preload" href="/the-blog/assets/js/2.233f3245.js" as="script"><link rel="preload" href="/the-blog/assets/js/19.19f57d70.js" as="script"><link rel="prefetch" href="/the-blog/assets/js/10.d64c4eff.js"><link rel="prefetch" href="/the-blog/assets/js/11.71c5d6b7.js"><link rel="prefetch" href="/the-blog/assets/js/12.11daf096.js"><link rel="prefetch" href="/the-blog/assets/js/13.f69b548d.js"><link rel="prefetch" href="/the-blog/assets/js/14.d1ad4cff.js"><link rel="prefetch" href="/the-blog/assets/js/15.8509a816.js"><link rel="prefetch" href="/the-blog/assets/js/16.8d119a8f.js"><link rel="prefetch" href="/the-blog/assets/js/17.af1786ea.js"><link rel="prefetch" href="/the-blog/assets/js/18.a98290de.js"><link rel="prefetch" href="/the-blog/assets/js/20.280bb4ea.js"><link rel="prefetch" href="/the-blog/assets/js/21.6e34cef2.js"><link rel="prefetch" href="/the-blog/assets/js/22.6a817ce7.js"><link rel="prefetch" href="/the-blog/assets/js/23.b2f20c9f.js"><link rel="prefetch" href="/the-blog/assets/js/24.1c74258d.js"><link rel="prefetch" href="/the-blog/assets/js/25.9372330d.js"><link rel="prefetch" href="/the-blog/assets/js/3.e85ca41f.js"><link rel="prefetch" href="/the-blog/assets/js/4.05f254cc.js"><link rel="prefetch" href="/the-blog/assets/js/5.aa528bc2.js"><link rel="prefetch" href="/the-blog/assets/js/6.73a8f323.js"><link rel="prefetch" href="/the-blog/assets/js/7.f3388b10.js"><link rel="prefetch" href="/the-blog/assets/js/8.5af9c977.js"><link rel="prefetch" href="/the-blog/assets/js/9.12eb1627.js">
    <link rel="stylesheet" href="/the-blog/assets/css/0.styles.5847df6a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/the-blog/" class="home-link router-link-active"><!----> <span class="site-name">Vue 源码解析</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/the-blog/introduction/" class="sidebar-link">介绍</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>准备工作</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/the-blog/simple/" class="sidebar-link">提取简易版</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>创建Vue实例</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Observer</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/the-blog/observer/state/" aria-current="page" class="active sidebar-link">state</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/the-blog/observer/state/#观察者模式" class="sidebar-link">观察者模式</a></li><li class="sidebar-sub-header"><a href="/the-blog/observer/state/#添加state逻辑" class="sidebar-link">添加state逻辑</a></li></ul></li><li><a href="/the-blog/observer/Observer/" class="sidebar-link">Observe</a></li><li><a href="/the-blog/observer/Dep/" class="sidebar-link">Dep</a></li><li><a href="/the-blog/observer/Watcher/" class="sidebar-link">Watcher</a></li><li><a href="/the-blog/observer/Notify/" class="sidebar-link">Notify</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="state"><a href="#state" class="header-anchor">#</a> state</h1> <p>上一章遗留的问题updateComponent为什么放到新建的渲染Watcher执行，这是因为vue是利用数据响应式来实现数据驱动的，updateComponent是渲染组件的方法，首次加载或者数据变化都应该执行updateComponent完成组件的更新。为什么数据变化就可以自动执行updateComponent更新组件，这就是vue的响应式系统要做的事。</p> <h2 id="观察者模式"><a href="#观察者模式" class="header-anchor">#</a> 观察者模式</h2> <p>vue响应式系统使用的是观察者模式，观察者模式与发布订阅模式很像，都需要依赖收集和事件发布。从一个例子了解vue的观察者模式。</p> <p>宿舍住了一群人想装修宿舍，他们每个人都有一个电话本，上面可以记录装修师傅的电话。如果有人想粉刷墙，他得先在自己的电话本记录刷墙师傅的电话，然后才能联系师傅来刷墙，如果有人想装地板，就得记录装地板师傅的电话再联系。</p> <p>vue的data数据就表示宿舍的舍员，他们的电话本就是后面要讲的Dep，用来收集依赖的容器，电话本收集的其实是装修师傅们的电话，需要刷墙就得收集刷墙师傅的电话。每一位装修师傅表示的就是后面要讲的Watcher，他具有某项技能负责具体的施工。所以如果哪位舍员想装修房子，只需要打开自己的电话本联系自己收集的装修师傅就可以了，联系师傅这一步骤就叫做事件发布。</p> <h2 id="添加state逻辑"><a href="#添加state逻辑" class="header-anchor">#</a> 添加state逻辑</h2> <p>本小节提供了在简易版基础上添加state功能版本<a href="">源码地址</a>。下面简单分析一下这个版本都具体添加了哪些逻辑。</p> <p>打开mysrc/core/instance/index.js，添加stateMixin方法</p> <div class="language- extra-class"><pre class="language-text"><code>function Vue (options) {
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)
export default Vue
</code></pre></div><p>stateMixin在mysrc/core/instance/state.js中定义，查看stateMixin方法的实现</p> <div class="language- extra-class"><pre class="language-text"><code>export function stateMixin (Vue) {

  const dataDef = {}
  dataDef.get = function () { return this._data }

  Object.defineProperty(Vue.prototype, '$data', dataDef)

  Vue.prototype.$set = set
  Vue.prototype.$delete = del

}
</code></pre></div><p>stateMixin方法主要对Vue.prototype添加了$data属性、$set方法、$delete方法和$watch方法。$data属性的get方法返回的就是用户再data中返回的数据对象，暴露给用户使用vm.$data就可以获取Vue 实例观察的数据对象。因为 Vue 无法探测普通的新增或删除 property (比如 this.myObject.newProperty = 'hi')，所以内置了$set和$delete方法，使新增的属性变成响应式的，他俩的实现这里不展开讲后面再了解。</p> <p>data变成响应式的过程是在_init方法中调用的initState实现的</p> <div class="language- extra-class"><pre class="language-text"><code>Vue.prototype._init = function (options) {
  ...
  vm._renderProxy = vm
  vm._self = vm
  initRender(vm)
  initState(vm)
  ...
}
</code></pre></div><p>initState定义在mysrc/core/instance/state.js中</p> <div class="language- extra-class"><pre class="language-text"><code>export function initState (vm) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
}
</code></pre></div><p>当用户写了data时，使用initData方法处理：</p> <div class="language- extra-class"><pre class="language-text"><code>function initData (vm) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  // proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods &amp;&amp; hasOwn(methods, key)) {
        warn(
          `Method &quot;${key}&quot; has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props &amp;&amp; hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' &amp;&amp; warn(
        `The data property &quot;${key}&quot; is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  observe(data, true /* asRootData */)
}
</code></pre></div><p>因为vue建议data写成函数形式同时也支持直接把data写成对象，先判断如果是函数类型通过getData获取函数返回值，如果data是对象类型直接返回data，接着对data中的属性与props或者methods重名的判断，并在开发环境中警告提示，然后通过proxy把data返回的属性代理到vm实例上，也就是把data数据声明到vm实例，这也就是为什么直接使用this.xxx就能访问到data数据的原因。最后执行observe方法。</p> <p>总结：到此为止state版本就已经为实现数据的响应式做好了准备，下面就开始重点分析Observe到底是怎么实现响应式的。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/the-blog/instance/VNode/" class="prev">
        VNode
      </a></span> <span class="next"><a href="/the-blog/observer/Observer/">
        Observe
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/the-blog/assets/js/app.be1bf052.js" defer></script><script src="/the-blog/assets/js/2.233f3245.js" defer></script><script src="/the-blog/assets/js/19.19f57d70.js" defer></script>
  </body>
</html>
