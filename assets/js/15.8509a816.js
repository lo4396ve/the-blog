(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{381:function(e,n,t){"use strict";t.r(n);var s=t(45),a=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"notify"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#notify"}},[e._v("#")]),e._v(" Notify")]),e._v(" "),t("p",[e._v("这一节介绍响应式系统是如何派发通知的。")]),e._v(" "),t("p",[e._v("回顾defineReactive方法中的set逻辑")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Object.defineProperty(obj, key, {\n  enumerable: true,\n  configurable: true,\n  get: function reactiveGetter () {\n    ...\n  },\n  set: function reactiveSetter (newVal) {\n    const value = getter ? getter.call(obj) : val\n    if (newVal === value || (newVal !== newVal && value !== value)) {\n      return\n    }\n    if (process.env.NODE_ENV !== 'production' && customSetter) {\n      customSetter()\n    }\n    // #7981: for accessor properties without setter\n    if (getter && !setter) return\n    if (setter) {\n      setter.call(obj, newVal)\n    } else {\n      val = newVal\n    }\n    childOb = !shallow && observe(newVal)\n    dep.notify()\n  }\n})\n")])])]),t("p",[e._v("判断新旧值是否发生变化，如果没变化不做处理。如果在非生产环境用户自定义了customSetter方法，执行自定义setter方法，最后通过observe(newVal)使新设置的值变成响应式数据，最关键一步是调用dep.notify()方法。")]),e._v(" "),t("p",[e._v("打开mysrc/core/observer/dep.js，找到notify方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("notify () {\n  // stabilize the subscriber list first\n  const subs = this.subs.slice()\n  if (process.env.NODE_ENV !== 'production' && !config.async) {\n    subs.sort((a, b) => a.id - b.id)\n  }\n  for (let i = 0, l = subs.length; i < l; i++) {\n    subs[i].update()\n  }\n}\n")])])]),t("p",[e._v("其实就是把数据收集的Watcher实例遍历执行update()方法。")]),e._v(" "),t("p",[e._v("在mysrc/core/observer/watcher.js中查找update方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true\n  } else if (this.sync) {\n    this.run()\n  } else {\n    queueWatcher(this)\n  }\n}\n")])])]),t("p",[e._v("lazy的作用与计算属性computed有关，这个后面再详细介绍，此时lazy为false，sync代表同步更新这里也不展开介绍，sync的值也为false，所以最终执行的是queueWatcher。")]),e._v(" "),t("p",[e._v("打开mysrc/core/observer/scheduler.js查看queueWatcher方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("const queue = []\nexport function queueWatcher (watcher) {\n  const id = watcher.id\n  if (has[id] == null) {\n    has[id] = true\n    if (!flushing) {\n      queue.push(watcher)\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      let i = queue.length - 1\n      while (i > index && queue[i].id > watcher.id) {\n        i--\n      }\n      queue.splice(i + 1, 0, watcher)\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true\n\n      if (process.env.NODE_ENV !== 'production' && !config.async) {\n        flushSchedulerQueue()\n        return\n      }\n      nextTick(flushSchedulerQueue)\n    }\n  }\n}\n")])])]),t("p",[e._v("该文件维护了一个队列，所有需要执行的Watcher都放入这个队列，在入队之前先对去重做处理，最后通过nextTick执行flushSchedulerQueue。nextTick的目的是为了保证这些更新操作都在下一个任务tick执行，nextTick的实现逻辑暂且不管，先看一下flushSchedulerQueue方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function flushSchedulerQueue () {\n  currentFlushTimestamp = getNow()\n  flushing = true\n  let watcher, id\n\n  queue.sort((a, b) => a.id - b.id)\n\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index]\n    if (watcher.before) {\n      watcher.before()\n    }\n    id = watcher.id\n    has[id] = null\n    watcher.run()\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? `in watcher with expression \"${watcher.expression}\"`\n              : `in a component render function.`\n          ),\n          watcher.vm\n        )\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  const activatedQueue = activatedChildren.slice()\n  const updatedQueue = queue.slice()\n\n  resetSchedulerState()\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue)\n  callUpdatedHooks(updatedQueue)\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush')\n  }\n}\n")])])]),t("p",[e._v("核心逻辑是遍历watcher执行run方法，打开mysrc/core/observer/watcher.js查找run方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('run () {\n  if (this.active) {\n    const value = this.get()\n    if (\n      value !== this.value ||\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      const oldValue = this.value\n      this.value = value\n      if (this.user) {\n        const info = `callback for watcher "${this.expression}"`\n        invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info)\n      } else {\n        this.cb.call(this.vm, value, oldValue)\n      }\n    }\n  }\n}\n')])])]),t("p",[e._v("run方法首先调用this.get方法求值，this.get内部会执行this.getter方法，对于renderWatcher前面分析this.getter就是传给Watcher的updateComponent方法，所以在updateComponent内部会执行_render方法，从而实现重新渲染的效果。")]),e._v(" "),t("p",[e._v("this.user为true时表示这个watcher是用户自己写的watcher，这里渲染watcher是vue内置的watcher。最终都是执行this.cb方法。其实invokeWithErrorHandling的作用就是把this.cb放在try...catch结构体执行，为了方便捕获错误。事实上我们通常在vue中这样使用watch")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vm.$watch('a.b.c', function (newVal, oldVal) {\n  // 做点什么\n})\n// 或者\nwatch: {\n  // 如果 `question` 发生改变，这个函数就会运行\n  question: function (newQuestion, oldQuestion) {\n    this.answer = 'Waiting for you to stop typing...'\n    this.debouncedGetAnswer()\n  }\n}\n")])])]),t("p",[e._v("调用this.cb回调方法时把新旧值都传给了cb，所以用户自己写的watch能在回调方法里面获取新值和旧值。对于renderWatcher，this.cb是个空函数noop。")])])}),[],!1,null,null,null);n.default=a.exports}}]);