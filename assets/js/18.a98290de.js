(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{383:function(e,t,n){"use strict";n.r(t);var s=n(45),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"watcher"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#watcher"}},[e._v("#")]),e._v(" Watcher")]),e._v(" "),n("p",[e._v("下面看一下Watcher的实现，打开mysrc/core/observer/watcher.js")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export default class Watcher {\n  constructor (\n    vm,\n    expOrFn,\n    cb,\n    options,\n    isRenderWatcher\n  ) {\n    this.vm = vm\n    if (isRenderWatcher) {\n      vm._watcher = this\n    }\n    vm._watchers.push(this)\n    // options\n    if (options) {\n      this.deep = !!options.deep\n      this.user = !!options.user\n      this.lazy = !!options.lazy\n      this.sync = !!options.sync\n      this.before = options.before\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false\n    }\n    this.cb = cb\n    this.id = ++uid // uid for batching\n    this.active = true\n    this.dirty = this.lazy // for lazy watchers\n    this.deps = []\n    this.newDeps = []\n    this.depIds = new Set()\n    this.newDepIds = new Set()\n    this.expression = process.env.NODE_ENV !== 'production'\n      ? expOrFn.toString()\n      : ''\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n      if (!this.getter) {\n        this.getter = noop\n        process.env.NODE_ENV !== 'production' && warn(\n          `Failed watching path: \"${expOrFn}\" ` +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        )\n      }\n    }\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  get () {\n    pushTarget(this)\n    let value\n    const vm = this.vm\n    try {\n      value = this.getter.call(vm, vm)\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, `getter for watcher \"${this.expression}\"`)\n      } else {\n        throw e\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value)\n      }\n      popTarget()\n      this.cleanupDeps()\n    }\n    return value\n  }\n\n  /**\n   * Add a dependency to this directive.\n   */\n  addDep (dep) {\n    const id = dep.id\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id)\n      this.newDeps.push(dep)\n      if (!this.depIds.has(id)) {\n        dep.addSub(this)\n      }\n    }\n  }\n\n  /**\n   * Clean up for dependency collection.\n   */\n  cleanupDeps () {\n    let i = this.deps.length\n    while (i--) {\n      const dep = this.deps[i]\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this)\n      }\n    }\n    let tmp = this.depIds\n    this.depIds = this.newDepIds\n    this.newDepIds = tmp\n    this.newDepIds.clear()\n    tmp = this.deps\n    this.deps = this.newDeps\n    this.newDeps = tmp\n    this.newDeps.length = 0\n  }\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n  update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true\n    } else if (this.sync) {\n      this.run()\n    } else {\n      queueWatcher(this)\n    }\n  }\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  run () {\n    if (this.active) {\n      const value = this.get()\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        const oldValue = this.value\n        this.value = value\n        if (this.user) {\n          const info = `callback for watcher \"${this.expression}\"`\n          invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info)\n        } else {\n          this.cb.call(this.vm, value, oldValue)\n        }\n      }\n    }\n  }\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n  evaluate () {\n    this.value = this.get()\n    this.dirty = false\n  }\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n  depend () {\n    let i = this.deps.length\n    while (i--) {\n      this.deps[i].depend()\n    }\n  }\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n  teardown () {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this)\n      }\n      let i = this.deps.length\n      while (i--) {\n        this.deps[i].removeSub(this)\n      }\n      this.active = false\n    }\n  }\n}\n")])])]),n("p",[e._v("Watcher定义了一些与dep相关的方法，单存看Watcher的逻辑比较难理解，结合之前的updateComponent方法分析逻辑就会比较清晰，在Vue的mount过程中，mountComponent函数预留的一段代码：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let updateComponent\n  \nupdateComponent = () => {\n  vm._update(vm._render())\n}\n\nnew Watcher(vm, updateComponent, noop, {\n  before () {\n    if (vm._isMounted && !vm._isDestroyed) {\n      // callHook(vm, 'beforeUpdate')\n    }\n  }\n}, true /* isRenderWatcher */)\n")])])]),n("p",[e._v("new Watcher传了五个参数，第一个是当前实例vm，第二个是updateComponent，第三个是一个空函数noop，第四个是一个对象，包含了一个before钩子函数，第五个参数是用来通知Watcher当前创建的是一个renderWatcher。")]),e._v(" "),n("p",[e._v("还记得最一开始的那个形象的比喻，watcher代表具有专项技能的工具人，那renderWatcher的意思就是代表当前是一个具备render渲染功能的watcher，所有需要执行渲染逻辑的地方都得通过renderWatcher，而data响应式就是当数据变化是执行渲染逻辑，所以每一个响应式的data数据都需要把renderWatcher收集起来，当数据发生变化是通过拦截set方法执行renderWatcher的渲染逻辑。赋予renderWatcher渲染功能，就是通过传给Watcher的第二个参数updateComponent实现的。")]),e._v(" "),n("p",[e._v("实际上面new Watcher时，在Watcher内部的执行逻辑是首先解析传进来的参数，expOrFn参数有两种类型情况，可以是function类型也可以是String类型，expOrFn传字符串的情况后面再分析，现在expOrFn传的就是updateComponent函数，所以this.getter = expOrFn，最后由于lazy的值为false，执行this.get方法。")]),e._v(" "),n("p",[e._v("在this.get方法内部执行了pushTarget(this)方法，this就是当前创建的renderWatcher实例对象。再回顾一下dep定义的pushTarget方法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export function pushTarget (target) {\n  targetStack.push(target)\n  Dep.target = target\n}\n")])])]),n("p",[e._v("通过pushTarget方法，使得Dep.target静态属性指向当前renderWatcher实例对象，然后执行this.getter方法，上面已经知道this.getter方法就是传进来的updateComponent方法，这时候开始执行updateComponent方法")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("updateComponent = () => {\n  vm._update(vm._render())\n}\n")])])]),n("p",[e._v("updateComponent会执行_render方法，_render方法会访问data中的数据，由于这时data已经是响应式数据，所以会触发数据对象的getter。每个数据对象在执行defineReactive时都持有一个dep实例，在get方法中会执行dep.depend()方法，也就是Dep.target.addDep(this)，此时Dep.target是renderWatcher实例对象，回顾在Watcher中定义的addDep方法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("addDep (dep) {\n  const id = dep.id\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id)\n    this.newDeps.push(dep)\n    if (!this.depIds.has(id)) {\n      dep.addSub(this)\n    }\n  }\n}\n")])])]),n("p",[e._v("关于newDepIds的作用后面再分析，首先判断是否已经收集过当前Watcher，保证不重复收集，最后调用dep.addSub(this)方法，this就是当前wathcer实例，也就是把当前的 watcher 订阅到这个数据持有的 dep 的 subs 中。")]),e._v(" "),n("p",[e._v("实现收集依赖之后判断调deep如果为true，则调用traverse方法，这个方法使用递归的方式访问value的子属性，使得子属性也完成依赖收集。")]),e._v(" "),n("p",[e._v("然后执行popTarget方法：")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("export function popTarget () {\n  targetStack.pop()\n  Dep.target = targetStack[targetStack.length - 1]\n}\n")])])]),n("p",[e._v("在dep中还维护了一个targetStack栈，在vue组件嵌套的情况下，在处理父子节点过程中，先实例化父节点然后再实例化子节点，所以先创建了父组件的renderWatcher，再创建子组件的renderWatcher，而_render是从子到父节点的过程，先执行子节点的_render再执行父节点的_render。父子节点的renderWatcher依次压入targetStack栈，渲染阶段先执行子节点的_render，也就触发了子节点的依赖收集，此时收集的正是子节点的renderWatcher，子节点渲染收集完成，targetStack弹出栈顶，Dep.target等于父节点的renderWatcher，这时父节点data收集的是父节点的renderWatcher。 很巧妙的用了数据结构栈的原理实现了整个收集过程。")]),e._v(" "),n("p",[e._v("最后还有一个步骤执行cleanupDeps清楚依赖。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("cleanupDeps () {\n  let i = this.deps.length\n  while (i--) {\n    const dep = this.deps[i]\n    if (!this.newDepIds.has(dep.id)) {\n      dep.removeSub(this)\n    }\n  }\n  let tmp = this.depIds\n  this.depIds = this.newDepIds\n  this.newDepIds = tmp\n  this.newDepIds.clear()\n  tmp = this.deps\n  this.deps = this.newDeps\n  this.newDeps = tmp\n  this.newDeps.length = 0\n}\n")])])])])}),[],!1,null,null,null);t.default=a.exports}}]);