(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{374:function(e,n,t){"use strict";t.r(n);var o=t(45),r=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"mount"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mount"}},[e._v("#")]),e._v(" mount")]),e._v(" "),t("p",[e._v("前面的_init方法已经为挂载做好了准备，下面分析一下具体是如何挂载的。")]),e._v(" "),t("p",[e._v("开发过vue项目的应该都比较熟悉项目入口有一个main.js文件")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("new Vue({\n  render: h => {\n    return h(App)\n  },\n}).$mount('#app')\n")])])]),t("p",[e._v("这个$mount方法就是暴露出来用于挂载实例的。许多地方都定义了$mount方法，有在原型上直接定义的$mount方法，还有在platform目录下各个不同打包入口也重新定义了$mount方法。之所以这样设计，是把一些通用的逻辑定义在原型上的$mount，针对不同环境，再扩展对应环境需要的特有逻辑。")]),e._v(" "),t("p",[e._v("platform/web/entry-runtime.js")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import Vue from './runtime/index'\n\nexport default Vue\n")])])]),t("p",[e._v("我们重点研究的runtime-only版本的入口文件并没有扩展和重写原型上定义的$mount方法，查看原型上的$mount方法，原型$mount定义在platform/web/runtime/index.js:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import Vue from 'core/index'\nimport { mountComponent } from 'core/instance/lifecycle'\nimport {\n  query,\n} from 'web/util/index'\nVue.prototype.$mount = function (\n  el\n) {\n  el = el && query(el);\n  return mountComponent(this, el)\n}\n")])])]),t("p",[e._v("$mount方法接受 el参数，它表示挂载的元素，可以是字符串，也可以是 DOM 对象，如果是字符串在浏览器环境下会调用 query 方法转换成 DOM 对象，最后再调用mountComponent方法，定义在mysrc/core/instance/lifecycle.js 文件中")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function mountComponent (\n  vm,\n  el,\n) {\n  vm.$el = el\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode\n  }\n  // callHook(vm, 'beforeMount')\n\n  let updateComponent\n  /* istanbul ignore if */\n  updateComponent = () => {\n    vm._update(vm._render())\n  }\n\n  updateComponent();\n\n  // we set this to vm._watcher inside the watcher's constructor\n  // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n  // component's mounted hook), which relies on vm._watcher being already defined\n  function noop() {}\n  new Watcher(vm, updateComponent, noop, {\n    before () {\n      if (vm._isMounted && !vm._isDestroyed) {\n        // callHook(vm, 'beforeUpdate')\n      }\n    }\n  }, true /* isRenderWatcher */)\n  \n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    // callHook(vm, 'mounted')\n  }\n  return vm\n}\n")])])]),t("p",[e._v("这段代码的核心是updateComponent，创建一个渲染Watcher，Watcher的逻辑会在后面介绍响应式的章节分析，目前只需要知道Watcher的内部会调用updateComponent就足够了。而updateComponent方法中会调用vm._update方法，vm._update方法接受vm._render方法的返回结果作为参数，实际上vm._render方法返回的就是虚拟dom（VNode）。下面就开始分析_render方法的实现。")])])}),[],!1,null,null,null);n.default=r.exports}}]);