(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{389:function(n,e,t){"use strict";t.r(e);var o=t(45),i=Object(o.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"雏形"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#雏形"}},[n._v("#")]),n._v(" 雏形")]),n._v(" "),t("p",[n._v("从这一章节开始从源码src目录筛选出来一个仅支持挂载元素功能的雏形版本放在mysrc目录。虽然是简易版，但基础功能要有，保证打包之后放到vue-project是可以运行的。那么这个简易版需要包含Vue实例、虚拟dom、mount挂载逻辑。")]),n._v(" "),t("h2",{attrs:{id:"工具方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工具方法"}},[n._v("#")]),n._v(" 工具方法")]),n._v(" "),t("p",[n._v("工欲善其事必先利其器，源码提供了很多工具方法，比如isObject判断是否对象类型的方法，为了保证和源码结构一致，不妨直接把这些工具搬运到mysrc。大部分工具方法都很简单不作为重点研究对象，因为我们 重点研究的对象是vue的核心逻辑而不是这些工具。但其中有一些关键的工具方法在使用到的时候会深入分析。")]),n._v(" "),t("h3",{attrs:{id:"shared"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#shared"}},[n._v("#")]),n._v(" shared")]),n._v(" "),t("p",[n._v("根据前面对src目录结构的分析，shared提供浏览器端和服务端是通用的方法，直接把shared整个搬运到mysrc，并对其中的代码稍加改动，主要是去除flow检查语法，具体的代码这里不贴出，本节最后会提供完整的代码。")]),n._v(" "),t("h3",{attrs:{id:"platform工具方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#platform工具方法"}},[n._v("#")]),n._v(" platform工具方法")]),n._v(" "),t("p",[n._v("根目录下找到platform/web/util，这里面提供了一些工具方法，是专门提供给web浏览器端使用的工具方法，比如判断一个标签是不是html标准标签。同样的在mysrc目录下也创建platform/web/util，整个搬运过去并且去除掉flow语法检查。")]),n._v(" "),t("h3",{attrs:{id:"core工具方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#core工具方法"}},[n._v("#")]),n._v(" core工具方法")]),n._v(" "),t("p",[n._v("根目录下找到core/util，也提供了一些工具方法，在创建操作Vue实例和操作VNode（虚拟dom）时用到的一些工具方法，比如mergeOptions合并参数的方法。也搬到mysrc目录下，同样去除flow。")]),n._v(" "),t("p",[n._v("到目前为止mysrc目录：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("mysrc\n├── core\n│   ├── util\n├── platforms\n│   ├── web\n│   │   ├── util\n│── shared\n│   ├── util\n│   ├── constants.js\n")])])]),t("p",[n._v("现在只搬运了一部分工具方法，在其他目录还有一些工具方法，在本节最后会随着探索全都搬运过来。")]),n._v(" "),t("h2",{attrs:{id:"入口文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#入口文件"}},[n._v("#")]),n._v(" 入口文件")]),n._v(" "),t("h3",{attrs:{id:"打包入口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#打包入口"}},[n._v("#")]),n._v(" 打包入口")]),n._v(" "),t("p",[n._v("打开src/platform/web目录，找到entry-runtime.js，这就是npm run dev:esm时的打包入口文件")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import Vue from './runtime/index'\n\nexport default Vue\n")])])]),t("p",[n._v("代码几乎没有逻辑，那么直接搬运到mysrc/platform/web/entry-runtime.js")]),n._v(" "),t("p",[n._v("entry-runtime.js其实什么都没做，只是从'./runtime/index'引入了Vue并暴露出去，说明真正的入口应该在./runtime/index这里。作者之所以这么写是因为在src/platform/web目录下还有其他的入口文件，如果打开entry-runtime-with-compiler.js发现除了从./runtime/index引入Vue，还对其进行扩展，扩展的主要是与compiler相关逻辑，而在entry-runtime.js中是不需要compiler的，所以什么都不需要做。")]),n._v(" "),t("p",[n._v("那么对于entry-runtime.js来说真正的入口应该是在./runtime/index，找到这个文件并打开，能看到这个文件虽然不长，但开始有点东西了，以最快的方式浏览一遍这个文件，捕获到关键的核心代码。\n根据语义捕获核心代码，这也是读源码的一个方法，并不是每一句代码都要去硬扣，在没有源码注释帮助的情况下，很难准确的判断这一段代码到底是干什么用的，唯一能做的就是根据英文语义化起名去猜，大部分情况能猜个八九不离十，从全局去提炼核心逻辑。很明显这个文件的核心是")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import Vue from 'core/index'\n\nVue.prototype.$mount = function (el) {\n  // el = el && inBrowser ? query(el) : undefined\n  el = el && query(el);\n  return mountComponent(this, el)\n}\n")])])]),t("p",[n._v("其他的代码可能重要可能不重要，我不知道，不确定重要的就先不管，先研究确定下来的。首先是又从core/index引入了Vue，那么说明Vue的定义很有可能是在core/index.js，这个先不管。下面的代码是对Vue的原型上添加了$mount方法，还记得之前在动手前的思考那一节分析main.js时，也对$mount方法进行了猜测，当时还大胆的假设$mount是一个静态法方法，看来是假设错了，$mount定义在了Vue的原型prototype上。")]),n._v(" "),t("p",[n._v("$mount内部定义了el变量，当你看到inBrowser这个判断条件时，应该能猜到这是在判断vue的运行环境是否在浏览器端运行，我们研究的就是vue在浏览器端运行的vue，所以直接简化为el = el && query(el); query是一个定义在web/util/index下的工具方法，工具搬运的时候就已经搬到了mysrc，query逻辑很简单，核心就是return document.querySelector(el); 建议去platform/web/util/index.js去自行查看query的完整代码，很简短一共十来行代码。$mount最后return mountComponent(this, el);")]),n._v(" "),t("p",[n._v("为了保证不报错，保留query和mountComponent的引入代码，得到完整版：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import Vue from 'core/index'\nimport { mountComponent } from 'core/instance/lifecycle'\nimport { query } from 'web/util/index'\n\nVue.prototype.$mount = function (el) {\n  el = el && query(el);\n  return mountComponent(this, el)\n}\n\nexport default Vue\n")])])]),t("p",[n._v("创建mysrc/platform/web/runtime/index.js，并把上述代码复制过去，目前mysrc已经有了打包入口文件")]),n._v(" "),t("blockquote",[t("p",[n._v("如果对源码里面的import Vue from 'core/index'感到疑惑，为什么'core/index'可以找到'src/core/index'，这是在rollup配置的别名，还记得前面把打包入口从src修改为mysrc的时候，修改了scripts/alias.js文件，这里面定义的就是别名，跟webpack的alias一个意思。")])]),n._v(" "),t("h3",{attrs:{id:"核心入口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心入口"}},[n._v("#")]),n._v(" 核心入口")]),n._v(" "),t("p",[n._v("目前为止，前一节遗留了两个问题需要解决，一个方向是研究core/index，另一个方向是研究mountComponent方法。应该选择第一个方向，因为mountComponent也是建立在Vue这个实例存在的基础上。")]),n._v(" "),t("p",[n._v("打开src/core/index.js:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import Vue from './instance/index'\nimport { initGlobalAPI } from './global-api/index'\nimport { isServerRendering } from 'core/util/env'\nimport { FunctionalRenderContext } from 'core/vdom/create-functional-component'\n\ninitGlobalAPI(Vue)\n\nObject.defineProperty(Vue.prototype, '$isServer', {\n  get: isServerRendering\n})\n\nObject.defineProperty(Vue.prototype, '$ssrContext', {\n  get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n})\n\n// expose FunctionalRenderContext for ssr runtime helper installation\nObject.defineProperty(Vue, 'FunctionalRenderContext', {\n  value: FunctionalRenderContext\n})\n\nVue.version = '__VERSION__'\n\nexport default Vue\n")])])]),t("p",[n._v("同样的办法，快速浏览，捕获关键代码，发现对Vue.prototype原型上的$isServer、$ssrContext和FunctionalRenderContext三个属性进行了代理。首先从命名语义可以猜到$isServer、$ssrContext都与服务端渲染有关，FunctionalRenderContext猜测是跟渲染函数式组件相关的，暂且不管这部分代码，就只剩下initGlobalAPI(Vue)，从命名规范猜测应该是对Vue初始化了一些全局API，这部分代码是否是关键代码要不要保留？这就需要打开initGlobalAPI看一下了（请自行查看），initGlobalAPI内部主要在Vue上面扩展了一些属性和方法，比如Vue.util、Vue.nextTick、Vue.options，最后还执行了initUse(Vue)、initMixin(Vue)、initExtend(Vue)、initAssetRegisters(Vue);这些代码哪些重要哪些不重要弄不清楚，不清楚那就暂时搁置。")]),n._v(" "),t("p",[n._v("经过简化的core/index.js代码:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import Vue from './instance/index'\n\nVue.version = '__VERSION__'\n\nexport default Vue\n")])])]),t("p",[n._v("上述代码复制到mysrc/core/index.js")]),n._v(" "),t("p",[n._v("这时还没有找到Vue到底定义再了哪里，那就继续打开'./instance/index'。\n打开src/core/instance/index.js：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import { initMixin } from './init'\nimport { stateMixin } from './state'\nimport { renderMixin } from './render'\nimport { eventsMixin } from './events'\nimport { lifecycleMixin } from './lifecycle'\nimport { warn } from '../util/index'\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword')\n  }\n  this._init(options)\n}\n\ninitMixin(Vue)\nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue\n")])])]),t("p",[n._v("真相大白，Vue原来定义在了这里，在Vue构造方法内部代码很简短，只有this._init(options)这一行有用的代码，根据其调用方式，不用假设了_init肯定是实例方法。")]),n._v(" "),t("p",[n._v("代码最后还有initMixin(Vue)、stateMixin(Vue)、eventsMixin(Vue)、lifecycleMixin(Vue)、renderMixin(Vue)这五行代码，先根据名字猜测:")]),n._v(" "),t("ul",[t("li",[n._v("initMixin应该与初始化基本信息有关")]),n._v(" "),t("li",[n._v("stateMixin应该与数据或者状态有关，很有可能双向绑定的逻辑就在这里面")]),n._v(" "),t("li",[n._v("eventsMixin应该是与事件有关")]),n._v(" "),t("li",[n._v("lifecycleMixin应该与生命周期有关")]),n._v(" "),t("li",[n._v("renderMixin应该与渲染有关")])]),n._v(" "),t("p",[n._v("对于雏形版本来说，他们几个哪个有用哪个无用，也确实无法判断，打开他们对应的文件，发现initMixin对Vue.prototype扩展了_init方法，那就姑且只保留initMixin吧。")]),n._v(" "),t("p",[n._v("简化之后的core/instance/index.js代码为：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import { initMixin } from './init'\n\nfunction Vue (options) {\n  // init方法啊在initMixin被定义\n  this._init(options)\n}\n\ninitMixin(Vue)\n\nexport default Vue\n")])])]),t("p",[n._v("把上述代码复制到 mysrc/core/instance/index.js")]),n._v(" "),t("p",[n._v("继续打开initMixin对应的文件src/core/instance/init.js，只贴出关键代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export function initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    const vm = this\n    // a uid\n    vm._uid = uid++\n\n    let startTag, endTag\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = `vue-perf-start:${vm._uid}`\n      endTag = `vue-perf-end:${vm._uid}`\n      mark(startTag)\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, 'beforeCreate')\n    initInjections(vm) // resolve injections before data/props\n    initState(vm)\n    initProvide(vm) // resolve provide after data/props\n    callHook(vm, 'created')\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false)\n      mark(endTag)\n      measure(`vue ${vm._name} init`, startTag, endTag)\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n\n")])])]),t("p",[n._v("注意在_init内部定义的vm = this; 这是每次new Vue创建的实例对象，_init内部主要是对vm进行扩展。相信大家现在都学会了捕获核心代码了，核心代码定位到vm.$mount(vm.$options.el); 这个文件的逻辑都是围绕这这行代码的。而vm的$options属性来自于上面的merge options 合并options：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("if (options && options._isComponent) {\n  initInternalComponent(vm, options)\n} else {\n  vm.$options = mergeOptions(\n    resolveConstructorOptions(vm.constructor),\n    options || {},\n    vm\n  )\n}\n")])])]),t("p",[n._v("这里的if...else结合initInternalComponent和resolveConstructorOptions分析来看，目的都是为了在vm扩展$options属性，逻辑并不复杂不占用篇幅分析。大家可以自己花个三五分钟读一下initInternalComponent和resolveConstructorOptions，读的时候可以不用过于关心mergeOptions和extend方法，根据其名字就可以猜出他们的作用。")]),n._v(" "),t("p",[n._v("Vue源码非常规范，代码耦合度非常低，每个方法规定要做什么事情，就只做什么事情，不会把逻辑交错在不同的方法里面，所以这也是选择读Vue源码的原因之一。")]),n._v(" "),t("blockquote",[t("p",[n._v("注意，可能有人不理解为什么需要合并options，也不清楚$options属性是干什么的，这是因为在vue执行的时候，每个模板里面的标签最后都要初始化为Vue实例对象，比如")]),t("div",[t("p",[n._v(n._s(n.yourData))])]),n._v("，最终div和p都要创建Vue实例对象（继而创建虚拟dom），而且他们是父子节点关系，所以从数据关系来看，p的实例对象应该要继承自div实例对象，后面会把继承的逻辑补上。"),t("p")]),n._v(" "),t("p",[n._v("整理之后的init.js代码为：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import { extend, mergeOptions } from '../util/index'\n\nexport function initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    const vm = this\n\n    // a flag to avoid this being observed\n    /*一个防止vm实例自身被观察的标志位*/\n    vm._isVue = true\n    // merge options \n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}\n\nexport function initInternalComponent (vm, options) {\n  const opts = vm.$options = Object.create(vm.constructor.options)\n  // doing this because it's faster than dynamic enumeration.\n  const parentVnode = options._parentVnode\n  opts.parent = options.parent\n  opts._parentVnode = parentVnode\n\n  const vnodeComponentOptions = parentVnode.componentOptions\n  opts.propsData = vnodeComponentOptions.propsData\n  opts._parentListeners = vnodeComponentOptions.listeners\n  opts._renderChildren = vnodeComponentOptions.children\n  opts._componentTag = vnodeComponentOptions.tag\n\n  if (options.render) {\n    opts.render = options.render\n    opts.staticRenderFns = options.staticRenderFns\n  }\n}\n\nexport function resolveConstructorOptions (Ctor) {\n  let options = Ctor.options\n  if (Ctor.super) {\n    const superOptions = resolveConstructorOptions(Ctor.super)\n    const cachedSuperOptions = Ctor.superOptions\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions\n      // check if there are any late-modified/attached options (#4976)\n      const modifiedOptions = resolveModifiedOptions(Ctor)\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions)\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)\n      if (options.name) {\n        options.components[options.name] = Ctor\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  let modified\n  const latest = Ctor.options\n  const sealed = Ctor.sealedOptions\n  for (const key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) modified = {}\n      modified[key] = latest[key]\n    }\n  }\n  return modified\n}\n\n")])])]),t("p",[n._v("把上述代码复制到mysrc/core/instance/init.js。")]),n._v(" "),t("p",[n._v("对于Vue的本质的研究暂告一段落，目前为止，已经找到了Vue构造函数的定义，还弄清楚了当new Vue时主要就执行了_init方法，_init方法主要对实例对象vm扩展一些属性（目前主要是$options），_init最核心的是执行了vm.$mount(vm.$options.el); 思路敏锐的同学估计已经发现了，这就是核心入口这一节开始提出的疑问。当时提供了两个方向，一个是选择深入研究Vue本质，另一个是研究$mount里面的mountComponent方法，这时候就可以来研究\nmountComponent方法了。")]),n._v(" "),t("h3",{attrs:{id:"mountcomponent"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mountcomponent"}},[n._v("#")]),n._v(" mountComponent")]),n._v(" "),t("p",[n._v("再次回到platform/web/runtime/index.js，mountComponent定义在了core/instance/lifecycle，打开core/instance/lifecycle.js，代码非常多，碰到这种代码非常多的文件先不要着急放弃，要详细vue的代码规范，肯定不会是一堆杂乱无章的代码。现在最关心的应该是mountComponent方法。")]),n._v(" "),t("p",[n._v("找到该方法的定义，首先去除process.env.NODE_ENV !== 'production'判断的逻辑代码，在非生产环境下，无非就是多了一些warn提示信息，我们并不关心他。捕获其核心逻辑就是在mountComponent内部定义了updateComponent方法：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("updateComponent = () => {\n  vm._update(vm._render(), hydrating)\n}\n")])])]),t("p",[n._v("而在updateComponent内部最终调用了vm._update方法，但是updateComponent并没有直接执行，而是传给了在后面的代码new Watcher作为参数：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("new Watcher(vm, updateComponent, noop, {\n  before () {\n    if (vm._isMounted && !vm._isDestroyed) {\n      callHook(vm, 'beforeUpdate')\n    }\n  }\n}, true /* isRenderWatcher */)\n")])])]),t("p",[n._v("updateComponent实际上在new Watcher内部会执行，这就涉及到了响应式系统，单独拿Watcher来研究响应式系统是没有意义的，所以下一章会先把Vue的响应式研究明白，而响应式也是Vue的核心内容之一。")]),n._v(" "),t("p",[n._v("还剩一个问题_update方法。继续观察core/instance/lifecycle.js，在lifecycleMixin方法里面对Vue.prototype扩展了_update方法，")])])}),[],!1,null,null,null);e.default=i.exports}}]);