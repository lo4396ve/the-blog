(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{377:function(t,e,n){"use strict";n.r(e);var s=n(45),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"dep"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#dep"}},[t._v("#")]),t._v(" Dep")]),t._v(" "),n("p",[t._v("Observer利用Dep进行依赖收集，看下Dep是怎么实现的，打开mysrc/core/observer/dep.js")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export default class Dep {\n  // static target = null;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n\n  addSub (sub) {\n    this.subs.push(sub)\n  }\n\n  removeSub (sub) {\n    remove(this.subs, sub)\n  }\n\n  depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this)\n    }\n  }\n\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    if (process.env.NODE_ENV !== 'production' && !config.async) {\n      subs.sort((a, b) => a.id - b.id)\n    }\n    for (let i = 0, l = subs.length; i < l; i++) {\n      subs[i].update()\n    }\n  }\n}\n\nDep.target = null\nconst targetStack = []\n\nexport function pushTarget (target) {\n  targetStack.push(target)\n  Dep.target = target\n}\n\nexport function popTarget () {\n  targetStack.pop()\n  Dep.target = targetStack[targetStack.length - 1]\n}\n")])])]),n("p",[t._v("Dep类的实现代码比较简单，实例属性subs是对用来存放收集的Watcher实例额。主要看target，target是Dep的一个静态属性，静态属性的特点是在类中同时只有一个值，实际上Dep.target的值是一个Watcher实例对象，因为在vue中同时只能有一个Watcher被运行，所以利用静态属性这一特性，实现依赖收集的时候只能收集当前执行的Watcher，而不会导致收集发生混乱。说白了Dep就是管理Watcher的容器。")])])}),[],!1,null,null,null);e.default=a.exports}}]);