(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{380:function(e,n,t){"use strict";t.r(n);var r=t(45),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"observe"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#observe"}},[e._v("#")]),e._v(" Observe")]),e._v(" "),t("p",[e._v("打开mysrc/core/observer/index.js，找到observe方法的定义：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function observe (value, asRootData) {\n  if (!isObject(value) || value instanceof VNode) {\n    return\n  }\n  let ob\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__\n  } else if (\n    shouldObserve &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value)\n  }\n  if (asRootData && ob) {\n    ob.vmCount++\n  }\n  return ob\n}\n")])])]),t("p",[e._v("observe首先判断要操作的对象如果有__ob__属性并且value.__ob__是Observer类型的，说明该对象已经是一个响应式数据了，不需要再操作了。否则创建Observer实例对象。")]),e._v(" "),t("p",[e._v("Observer类的实现：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export class Observer {\n  \n  constructor (value) {\n    this.value = value\n    this.dep = new Dep()\n    this.vmCount = 0  // number of vms that have this object as root $data\n    def(value, '__ob__', this)\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods)\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys)\n      }\n      this.observeArray(value)\n    } else {\n      this.walk(value)\n    }\n  }\n\n  walk (obj) {\n    const keys = Object.keys(obj)\n    for (let i = 0; i < keys.length; i++) {\n      defineReactive(obj, keys[i])\n    }\n  }\n\n  observeArray (items) {\n    for (let i = 0, l = items.length; i < l; i++) {\n      observe(items[i])\n    }\n  }\n}\n")])])]),t("p",[e._v("首先通过def方法在对象上添加__ob__属性，并指向当前实例，说明该对象已经是一个响应式数据了。如果是数组类型，调用observeArray方法通过遍历加递归的方式，是得数组每一个数据都变成响应式数据，最终执行this.walk。walk会遍历对象每一个属性，并调用defineReactive方法。")]),e._v(" "),t("p",[e._v("defineReactive：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("export function defineReactive (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  const dep = new Dep()\n\n  const property = Object.getOwnPropertyDescriptor(obj, key)\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  const getter = property && property.get\n  const setter = property && property.set\n  if ((!getter || setter) && arguments.length === 2) {\n    val = obj[key]\n  }\n\n  let childOb = !shallow && observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      const value = getter ? getter.call(obj) : val\n      if (Dep.target) {\n        dep.depend()\n        if (childOb) {\n          childOb.dep.depend()\n          if (Array.isArray(value)) {\n            dependArray(value)\n          }\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      const value = getter ? getter.call(obj) : val\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter()\n      }\n      // #7981: for accessor properties without setter\n      if (getter && !setter) return\n      if (setter) {\n        setter.call(obj, newVal)\n      } else {\n        val = newVal\n      }\n      childOb = !shallow && observe(newVal)\n      dep.notify()\n    }\n  })\n}\n")])])]),t("p",[e._v("defineReactive方法首先会实例化一个Dep对象用来收集依赖，通过递归的方式对子对象调用observe方法，这样对象多层嵌套({a: {b: {c: '1'}}})的情况也能保证每个子属性都是响应式的。代码的核心是使用Object.defineProperty方法重写属性的get和set方法。在get方法中使用dep.depend进行依赖收集，在set方法中使用dep.notify通知订阅的事件。")])])}),[],!1,null,null,null);n.default=a.exports}}]);