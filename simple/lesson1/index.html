<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>雏形 | Vue 源码解析</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Vue源码解析 从new Vue源码还原">
    
    <link rel="preload" href="/the-blog/assets/css/0.styles.5847df6a.css" as="style"><link rel="preload" href="/the-blog/assets/js/app.be1bf052.js" as="script"><link rel="preload" href="/the-blog/assets/js/2.233f3245.js" as="script"><link rel="preload" href="/the-blog/assets/js/25.9372330d.js" as="script"><link rel="prefetch" href="/the-blog/assets/js/10.d64c4eff.js"><link rel="prefetch" href="/the-blog/assets/js/11.71c5d6b7.js"><link rel="prefetch" href="/the-blog/assets/js/12.11daf096.js"><link rel="prefetch" href="/the-blog/assets/js/13.f69b548d.js"><link rel="prefetch" href="/the-blog/assets/js/14.d1ad4cff.js"><link rel="prefetch" href="/the-blog/assets/js/15.8509a816.js"><link rel="prefetch" href="/the-blog/assets/js/16.8d119a8f.js"><link rel="prefetch" href="/the-blog/assets/js/17.af1786ea.js"><link rel="prefetch" href="/the-blog/assets/js/18.a98290de.js"><link rel="prefetch" href="/the-blog/assets/js/19.19f57d70.js"><link rel="prefetch" href="/the-blog/assets/js/20.280bb4ea.js"><link rel="prefetch" href="/the-blog/assets/js/21.6e34cef2.js"><link rel="prefetch" href="/the-blog/assets/js/22.6a817ce7.js"><link rel="prefetch" href="/the-blog/assets/js/23.b2f20c9f.js"><link rel="prefetch" href="/the-blog/assets/js/24.1c74258d.js"><link rel="prefetch" href="/the-blog/assets/js/3.e85ca41f.js"><link rel="prefetch" href="/the-blog/assets/js/4.05f254cc.js"><link rel="prefetch" href="/the-blog/assets/js/5.aa528bc2.js"><link rel="prefetch" href="/the-blog/assets/js/6.73a8f323.js"><link rel="prefetch" href="/the-blog/assets/js/7.f3388b10.js"><link rel="prefetch" href="/the-blog/assets/js/8.5af9c977.js"><link rel="prefetch" href="/the-blog/assets/js/9.12eb1627.js">
    <link rel="stylesheet" href="/the-blog/assets/css/0.styles.5847df6a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/the-blog/" class="home-link router-link-active"><!----> <span class="site-name">Vue 源码解析</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/the-blog/introduction/" class="sidebar-link">介绍</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>准备工作</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/the-blog/simple/" aria-current="page" class="sidebar-link">提取简易版</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>创建Vue实例</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Observer</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="雏形"><a href="#雏形" class="header-anchor">#</a> 雏形</h1> <p>从这一章节开始从源码src目录筛选出来一个仅支持挂载元素功能的雏形版本放在mysrc目录。虽然是简易版，但基础功能要有，保证打包之后放到vue-project是可以运行的。那么这个简易版需要包含Vue实例、虚拟dom、mount挂载逻辑。</p> <h2 id="工具方法"><a href="#工具方法" class="header-anchor">#</a> 工具方法</h2> <p>工欲善其事必先利其器，源码提供了很多工具方法，比如isObject判断是否对象类型的方法，为了保证和源码结构一致，不妨直接把这些工具搬运到mysrc。大部分工具方法都很简单不作为重点研究对象，因为我们 重点研究的对象是vue的核心逻辑而不是这些工具。但其中有一些关键的工具方法在使用到的时候会深入分析。</p> <h3 id="shared"><a href="#shared" class="header-anchor">#</a> shared</h3> <p>根据前面对src目录结构的分析，shared提供浏览器端和服务端是通用的方法，直接把shared整个搬运到mysrc，并对其中的代码稍加改动，主要是去除flow检查语法，具体的代码这里不贴出，本节最后会提供完整的代码。</p> <h3 id="platform工具方法"><a href="#platform工具方法" class="header-anchor">#</a> platform工具方法</h3> <p>根目录下找到platform/web/util，这里面提供了一些工具方法，是专门提供给web浏览器端使用的工具方法，比如判断一个标签是不是html标准标签。同样的在mysrc目录下也创建platform/web/util，整个搬运过去并且去除掉flow语法检查。</p> <h3 id="core工具方法"><a href="#core工具方法" class="header-anchor">#</a> core工具方法</h3> <p>根目录下找到core/util，也提供了一些工具方法，在创建操作Vue实例和操作VNode（虚拟dom）时用到的一些工具方法，比如mergeOptions合并参数的方法。也搬到mysrc目录下，同样去除flow。</p> <p>到目前为止mysrc目录：</p> <div class="language- extra-class"><pre class="language-text"><code>mysrc
├── core
│   ├── util
├── platforms
│   ├── web
│   │   ├── util
│── shared
│   ├── util
│   ├── constants.js
</code></pre></div><p>现在只搬运了一部分工具方法，在其他目录还有一些工具方法，在本节最后会随着探索全都搬运过来。</p> <h2 id="入口文件"><a href="#入口文件" class="header-anchor">#</a> 入口文件</h2> <h3 id="打包入口"><a href="#打包入口" class="header-anchor">#</a> 打包入口</h3> <p>打开src/platform/web目录，找到entry-runtime.js，这就是npm run dev:esm时的打包入口文件</p> <div class="language- extra-class"><pre class="language-text"><code>import Vue from './runtime/index'

export default Vue
</code></pre></div><p>代码几乎没有逻辑，那么直接搬运到mysrc/platform/web/entry-runtime.js</p> <p>entry-runtime.js其实什么都没做，只是从'./runtime/index'引入了Vue并暴露出去，说明真正的入口应该在./runtime/index这里。作者之所以这么写是因为在src/platform/web目录下还有其他的入口文件，如果打开entry-runtime-with-compiler.js发现除了从./runtime/index引入Vue，还对其进行扩展，扩展的主要是与compiler相关逻辑，而在entry-runtime.js中是不需要compiler的，所以什么都不需要做。</p> <p>那么对于entry-runtime.js来说真正的入口应该是在./runtime/index，找到这个文件并打开，能看到这个文件虽然不长，但开始有点东西了，以最快的方式浏览一遍这个文件，捕获到关键的核心代码。
根据语义捕获核心代码，这也是读源码的一个方法，并不是每一句代码都要去硬扣，在没有源码注释帮助的情况下，很难准确的判断这一段代码到底是干什么用的，唯一能做的就是根据英文语义化起名去猜，大部分情况能猜个八九不离十，从全局去提炼核心逻辑。很明显这个文件的核心是</p> <div class="language- extra-class"><pre class="language-text"><code>import Vue from 'core/index'

Vue.prototype.$mount = function (el) {
  // el = el &amp;&amp; inBrowser ? query(el) : undefined
  el = el &amp;&amp; query(el);
  return mountComponent(this, el)
}
</code></pre></div><p>其他的代码可能重要可能不重要，我不知道，不确定重要的就先不管，先研究确定下来的。首先是又从core/index引入了Vue，那么说明Vue的定义很有可能是在core/index.js，这个先不管。下面的代码是对Vue的原型上添加了$mount方法，还记得之前在动手前的思考那一节分析main.js时，也对$mount方法进行了猜测，当时还大胆的假设$mount是一个静态法方法，看来是假设错了，$mount定义在了Vue的原型prototype上。</p> <p>$mount内部定义了el变量，当你看到inBrowser这个判断条件时，应该能猜到这是在判断vue的运行环境是否在浏览器端运行，我们研究的就是vue在浏览器端运行的vue，所以直接简化为el = el &amp;&amp; query(el); query是一个定义在web/util/index下的工具方法，工具搬运的时候就已经搬到了mysrc，query逻辑很简单，核心就是return document.querySelector(el); 建议去platform/web/util/index.js去自行查看query的完整代码，很简短一共十来行代码。$mount最后return mountComponent(this, el);</p> <p>为了保证不报错，保留query和mountComponent的引入代码，得到完整版：</p> <div class="language- extra-class"><pre class="language-text"><code>import Vue from 'core/index'
import { mountComponent } from 'core/instance/lifecycle'
import { query } from 'web/util/index'

Vue.prototype.$mount = function (el) {
  el = el &amp;&amp; query(el);
  return mountComponent(this, el)
}

export default Vue
</code></pre></div><p>创建mysrc/platform/web/runtime/index.js，并把上述代码复制过去，目前mysrc已经有了打包入口文件</p> <blockquote><p>如果对源码里面的import Vue from 'core/index'感到疑惑，为什么'core/index'可以找到'src/core/index'，这是在rollup配置的别名，还记得前面把打包入口从src修改为mysrc的时候，修改了scripts/alias.js文件，这里面定义的就是别名，跟webpack的alias一个意思。</p></blockquote> <h3 id="核心入口"><a href="#核心入口" class="header-anchor">#</a> 核心入口</h3> <p>目前为止，前一节遗留了两个问题需要解决，一个方向是研究core/index，另一个方向是研究mountComponent方法。应该选择第一个方向，因为mountComponent也是建立在Vue这个实例存在的基础上。</p> <p>打开src/core/index.js:</p> <div class="language- extra-class"><pre class="language-text"><code>import Vue from './instance/index'
import { initGlobalAPI } from './global-api/index'
import { isServerRendering } from 'core/util/env'
import { FunctionalRenderContext } from 'core/vdom/create-functional-component'

initGlobalAPI(Vue)

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
})

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get () {
    /* istanbul ignore next */
    return this.$vnode &amp;&amp; this.$vnode.ssrContext
  }
})

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
})

Vue.version = '__VERSION__'

export default Vue
</code></pre></div><p>同样的办法，快速浏览，捕获关键代码，发现对Vue.prototype原型上的$isServer、$ssrContext和FunctionalRenderContext三个属性进行了代理。首先从命名语义可以猜到$isServer、$ssrContext都与服务端渲染有关，FunctionalRenderContext猜测是跟渲染函数式组件相关的，暂且不管这部分代码，就只剩下initGlobalAPI(Vue)，从命名规范猜测应该是对Vue初始化了一些全局API，这部分代码是否是关键代码要不要保留？这就需要打开initGlobalAPI看一下了（请自行查看），initGlobalAPI内部主要在Vue上面扩展了一些属性和方法，比如Vue.util、Vue.nextTick、Vue.options，最后还执行了initUse(Vue)、initMixin(Vue)、initExtend(Vue)、initAssetRegisters(Vue);这些代码哪些重要哪些不重要弄不清楚，不清楚那就暂时搁置。</p> <p>经过简化的core/index.js代码:</p> <div class="language- extra-class"><pre class="language-text"><code>import Vue from './instance/index'

Vue.version = '__VERSION__'

export default Vue
</code></pre></div><p>上述代码复制到mysrc/core/index.js</p> <p>这时还没有找到Vue到底定义再了哪里，那就继续打开'./instance/index'。
打开src/core/instance/index.js：</p> <div class="language- extra-class"><pre class="language-text"><code>import { initMixin } from './init'
import { stateMixin } from './state'
import { renderMixin } from './render'
import { eventsMixin } from './events'
import { lifecycleMixin } from './lifecycle'
import { warn } from '../util/index'

function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &amp;&amp;
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}

initMixin(Vue)
stateMixin(Vue)
eventsMixin(Vue)
lifecycleMixin(Vue)
renderMixin(Vue)

export default Vue
</code></pre></div><p>真相大白，Vue原来定义在了这里，在Vue构造方法内部代码很简短，只有this._init(options)这一行有用的代码，根据其调用方式，不用假设了_init肯定是实例方法。</p> <p>代码最后还有initMixin(Vue)、stateMixin(Vue)、eventsMixin(Vue)、lifecycleMixin(Vue)、renderMixin(Vue)这五行代码，先根据名字猜测:</p> <ul><li>initMixin应该与初始化基本信息有关</li> <li>stateMixin应该与数据或者状态有关，很有可能双向绑定的逻辑就在这里面</li> <li>eventsMixin应该是与事件有关</li> <li>lifecycleMixin应该与生命周期有关</li> <li>renderMixin应该与渲染有关</li></ul> <p>对于雏形版本来说，他们几个哪个有用哪个无用，也确实无法判断，打开他们对应的文件，发现initMixin对Vue.prototype扩展了_init方法，那就姑且只保留initMixin吧。</p> <p>简化之后的core/instance/index.js代码为：</p> <div class="language- extra-class"><pre class="language-text"><code>import { initMixin } from './init'

function Vue (options) {
  // init方法啊在initMixin被定义
  this._init(options)
}

initMixin(Vue)

export default Vue
</code></pre></div><p>把上述代码复制到 mysrc/core/instance/index.js</p> <p>继续打开initMixin对应的文件src/core/instance/init.js，只贴出关键代码：</p> <div class="language- extra-class"><pre class="language-text"><code>export function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    const vm = this
    // a uid
    vm._uid = uid++

    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // a flag to avoid this being observed
    vm._isVue = true
    // merge options
    if (options &amp;&amp; options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }
    // expose real self
    vm._self = vm
    initLifecycle(vm)
    initEvents(vm)
    initRender(vm)
    callHook(vm, 'beforeCreate')
    initInjections(vm) // resolve injections before data/props
    initState(vm)
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}

</code></pre></div><p>注意在_init内部定义的vm = this; 这是每次new Vue创建的实例对象，_init内部主要是对vm进行扩展。相信大家现在都学会了捕获核心代码了，核心代码定位到vm.$mount(vm.$options.el); 这个文件的逻辑都是围绕这这行代码的。而vm的$options属性来自于上面的merge options 合并options：</p> <div class="language- extra-class"><pre class="language-text"><code>if (options &amp;&amp; options._isComponent) {
  initInternalComponent(vm, options)
} else {
  vm.$options = mergeOptions(
    resolveConstructorOptions(vm.constructor),
    options || {},
    vm
  )
}
</code></pre></div><p>这里的if...else结合initInternalComponent和resolveConstructorOptions分析来看，目的都是为了在vm扩展$options属性，逻辑并不复杂不占用篇幅分析。大家可以自己花个三五分钟读一下initInternalComponent和resolveConstructorOptions，读的时候可以不用过于关心mergeOptions和extend方法，根据其名字就可以猜出他们的作用。</p> <p>Vue源码非常规范，代码耦合度非常低，每个方法规定要做什么事情，就只做什么事情，不会把逻辑交错在不同的方法里面，所以这也是选择读Vue源码的原因之一。</p> <blockquote><p>注意，可能有人不理解为什么需要合并options，也不清楚$options属性是干什么的，这是因为在vue执行的时候，每个模板里面的标签最后都要初始化为Vue实例对象，比如</p><div><p></p></div>，最终div和p都要创建Vue实例对象（继而创建虚拟dom），而且他们是父子节点关系，所以从数据关系来看，p的实例对象应该要继承自div实例对象，后面会把继承的逻辑补上。<p></p></blockquote> <p>整理之后的init.js代码为：</p> <div class="language- extra-class"><pre class="language-text"><code>import { extend, mergeOptions } from '../util/index'

export function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    const vm = this

    // a flag to avoid this being observed
    /*一个防止vm实例自身被观察的标志位*/
    vm._isVue = true
    // merge options 
    if (options &amp;&amp; options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }
}

export function initInternalComponent (vm, options) {
  const opts = vm.$options = Object.create(vm.constructor.options)
  // doing this because it's faster than dynamic enumeration.
  const parentVnode = options._parentVnode
  opts.parent = options.parent
  opts._parentVnode = parentVnode

  const vnodeComponentOptions = parentVnode.componentOptions
  opts.propsData = vnodeComponentOptions.propsData
  opts._parentListeners = vnodeComponentOptions.listeners
  opts._renderChildren = vnodeComponentOptions.children
  opts._componentTag = vnodeComponentOptions.tag

  if (options.render) {
    opts.render = options.render
    opts.staticRenderFns = options.staticRenderFns
  }
}

export function resolveConstructorOptions (Ctor) {
  let options = Ctor.options
  if (Ctor.super) {
    const superOptions = resolveConstructorOptions(Ctor.super)
    const cachedSuperOptions = Ctor.superOptions
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions
      // check if there are any late-modified/attached options (#4976)
      const modifiedOptions = resolveModifiedOptions(Ctor)
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions)
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) {
        options.components[options.name] = Ctor
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  let modified
  const latest = Ctor.options
  const sealed = Ctor.sealedOptions
  for (const key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) modified = {}
      modified[key] = latest[key]
    }
  }
  return modified
}

</code></pre></div><p>把上述代码复制到mysrc/core/instance/init.js。</p> <p>对于Vue的本质的研究暂告一段落，目前为止，已经找到了Vue构造函数的定义，还弄清楚了当new Vue时主要就执行了_init方法，_init方法主要对实例对象vm扩展一些属性（目前主要是$options），_init最核心的是执行了vm.$mount(vm.$options.el); 思路敏锐的同学估计已经发现了，这就是核心入口这一节开始提出的疑问。当时提供了两个方向，一个是选择深入研究Vue本质，另一个是研究$mount里面的mountComponent方法，这时候就可以来研究
mountComponent方法了。</p> <h3 id="mountcomponent"><a href="#mountcomponent" class="header-anchor">#</a> mountComponent</h3> <p>再次回到platform/web/runtime/index.js，mountComponent定义在了core/instance/lifecycle，打开core/instance/lifecycle.js，代码非常多，碰到这种代码非常多的文件先不要着急放弃，要详细vue的代码规范，肯定不会是一堆杂乱无章的代码。现在最关心的应该是mountComponent方法。</p> <p>找到该方法的定义，首先去除process.env.NODE_ENV !== 'production'判断的逻辑代码，在非生产环境下，无非就是多了一些warn提示信息，我们并不关心他。捕获其核心逻辑就是在mountComponent内部定义了updateComponent方法：</p> <div class="language- extra-class"><pre class="language-text"><code>updateComponent = () =&gt; {
  vm._update(vm._render(), hydrating)
}
</code></pre></div><p>而在updateComponent内部最终调用了vm._update方法，但是updateComponent并没有直接执行，而是传给了在后面的代码new Watcher作为参数：</p> <div class="language- extra-class"><pre class="language-text"><code>new Watcher(vm, updateComponent, noop, {
  before () {
    if (vm._isMounted &amp;&amp; !vm._isDestroyed) {
      callHook(vm, 'beforeUpdate')
    }
  }
}, true /* isRenderWatcher */)
</code></pre></div><p>updateComponent实际上在new Watcher内部会执行，这就涉及到了响应式系统，单独拿Watcher来研究响应式系统是没有意义的，所以下一章会先把Vue的响应式研究明白，而响应式也是Vue的核心内容之一。</p> <p>还剩一个问题_update方法。继续观察core/instance/lifecycle.js，在lifecycleMixin方法里面对Vue.prototype扩展了_update方法，</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/the-blog/assets/js/app.be1bf052.js" defer></script><script src="/the-blog/assets/js/2.233f3245.js" defer></script><script src="/the-blog/assets/js/25.9372330d.js" defer></script>
  </body>
</html>
